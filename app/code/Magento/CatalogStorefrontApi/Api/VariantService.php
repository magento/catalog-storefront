<?php
# Generated by the Magento PHP proto generator.  DO NOT EDIT!

/**
 * Copyright Â© Magento, Inc. All rights reserved.
 * See COPYING.txt for license details.
 */

declare(strict_types=1);

namespace Magento\CatalogStorefrontApi\Api;

use \Magento\CatalogStorefrontApi\Api\Data\ImportVariantsRequestInterface;
use \Magento\CatalogStorefrontApi\Api\Data\ImportVariantsResponseInterface;
use \Magento\CatalogStorefrontApi\Api\Data\DeleteVariantsRequestInterface;
use \Magento\CatalogStorefrontApi\Api\Data\DeleteVariantsResponseInterface;
use \Magento\CatalogStorefrontApi\Api\Data\ProductVariantRequestInterface;
use \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponseInterface;
use \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequestInterface;
use \Magento\CatalogStorefrontApi\Proto\ImportVariantsRequest;
use \Magento\CatalogStorefrontApi\Proto\ImportVariantsResponse;
use \Magento\CatalogStorefrontApi\Proto\DeleteVariantsRequest;
use \Magento\CatalogStorefrontApi\Proto\DeleteVariantsResponse;
use \Magento\CatalogStorefrontApi\Proto\ProductVariantRequest;
use \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse;
use \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest;
use \Magento\CatalogStorefrontApi\Proto\VariantServiceClient;

/**
 * Autogenerated description for VariantService class
 *
 * @SuppressWarnings(PHPMD)
 */
class VariantService implements VariantServiceInterface
{
    /**
     * @var VariantServiceClient
     */
    private $protoClient;

    /**
     * @param string $hostname
     * @param array $options
     * @param string|null $channel
     */
    public function __construct(
        string $hostname,
        array $options,
        ?string $channel = null
    ) {
        $this->protoClient = new VariantServiceClient($hostname, $options, $channel);
    }

    /**
     * @inheritdoc
     *
     * @param ImportVariantsRequestInterface $request
     * @return ImportVariantsResponseInterface
     * @throws \Throwable
     */
    public function importProductVariants(ImportVariantsRequestInterface $request): ImportVariantsResponseInterface
    {
        $protoRequest = $this->importProductVariantsToProto($request);
        [$protoResult, $status] = $this->protoClient->importProductVariants($protoRequest)->wait();
        if ($status->code !== 0) {
            throw new \RuntimeException($status->details, $status->code);
        }
        return $this->importProductVariantsFromProto($protoResult);
    }

    /**
     * Autogenerated description for importProductVariants method
     *
     * @param ImportVariantsRequestInterface $value
     * @return ImportVariantsRequest
     */
    private function importProductVariantsToProto(ImportVariantsRequestInterface $value): ImportVariantsRequest
    {
        // convert data from \Magento\CatalogStorefrontApi\Api\Data\ImportVariantsRequest
        // to \Magento\CatalogStorefrontApi\Proto\ImportVariantsRequest
        /** @var \Magento\CatalogStorefrontApi\Api\Data\ImportVariantsRequest $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Proto\ImportVariantsRequest();
            $res = [];
            foreach ($value->getVariants() as $item1) {
                // convert data from \Magento\CatalogStorefrontApi\Api\Data\ProductVariantImport
                // to \Magento\CatalogStorefrontApi\Proto\ProductVariantImport
                /** @var \Magento\CatalogStorefrontApi\Api\Data\ProductVariantImport $item1 **/
                $p = function () use ($item1) {
                    $r = new \Magento\CatalogStorefrontApi\Proto\ProductVariantImport();
                    $r->setId($item1->getId());
                    $values = [];
                    foreach ($item1->getOptionValues() as $newValue) {
                        $values[] = $newValue;
                    }
                    $r->setOptionValues($values);
                    return $r;
                };
                $proto = $p();
                $res[] = $proto;
            }
            $r->setVariants($res);
            return $r;
        };
        $proto = $p();

        return $proto;
    }

    /**
     * Autogenerated description for importProductVariants method
     *
     * @param ImportVariantsResponse $value
     * @return ImportVariantsResponseInterface
     * phpcs:disable Generic.Metrics.NestingLevel.TooHigh
     */
    private function importProductVariantsFromProto(ImportVariantsResponse $value): ImportVariantsResponseInterface
    {
        // convert data from \Magento\CatalogStorefrontApi\Proto\ImportVariantsResponse
        // to \Magento\CatalogStorefrontApi\Api\Data\ImportVariantsResponse
        /** @var \Magento\CatalogStorefrontApi\Proto\ImportVariantsResponse $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Api\Data\ImportVariantsResponse();
            $r->setStatus($value->getStatus());
            $r->setMessage($value->getMessage());
            return $r;
        };
        $out = $p();

        return $out;
    }

    /**
     * @inheritdoc
     *
     * @param DeleteVariantsRequestInterface $request
     * @return DeleteVariantsResponseInterface
     * @throws \Throwable
     */
    public function deleteProductVariants(DeleteVariantsRequestInterface $request): DeleteVariantsResponseInterface
    {
        $protoRequest = $this->deleteProductVariantsToProto($request);
        [$protoResult, $status] = $this->protoClient->deleteProductVariants($protoRequest)->wait();
        if ($status->code !== 0) {
            throw new \RuntimeException($status->details, $status->code);
        }
        return $this->deleteProductVariantsFromProto($protoResult);
    }

    /**
     * Autogenerated description for deleteProductVariants method
     *
     * @param DeleteVariantsRequestInterface $value
     * @return DeleteVariantsRequest
     */
    private function deleteProductVariantsToProto(DeleteVariantsRequestInterface $value): DeleteVariantsRequest
    {
        // convert data from \Magento\CatalogStorefrontApi\Api\Data\DeleteVariantsRequest
        // to \Magento\CatalogStorefrontApi\Proto\DeleteVariantsRequest
        /** @var \Magento\CatalogStorefrontApi\Api\Data\DeleteVariantsRequest $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Proto\DeleteVariantsRequest();
            $values = [];
            foreach ($value->getId() as $newValue) {
                $values[] = $newValue;
            }
            $r->setId($values);
            return $r;
        };
        $proto = $p();

        return $proto;
    }

    /**
     * Autogenerated description for deleteProductVariants method
     *
     * @param DeleteVariantsResponse $value
     * @return DeleteVariantsResponseInterface
     * phpcs:disable Generic.Metrics.NestingLevel.TooHigh
     */
    private function deleteProductVariantsFromProto(DeleteVariantsResponse $value): DeleteVariantsResponseInterface
    {
        // convert data from \Magento\CatalogStorefrontApi\Proto\DeleteVariantsResponse
        // to \Magento\CatalogStorefrontApi\Api\Data\DeleteVariantsResponse
        /** @var \Magento\CatalogStorefrontApi\Proto\DeleteVariantsResponse $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Api\Data\DeleteVariantsResponse();
            $r->setStatus($value->getStatus());
            $r->setMessage($value->getMessage());
            return $r;
        };
        $out = $p();

        return $out;
    }

    /**
     * @inheritdoc
     *
     * @param ProductVariantRequestInterface $request
     * @return ProductVariantResponseInterface
     * @throws \Throwable
     */
    public function getProductVariants(ProductVariantRequestInterface $request): ProductVariantResponseInterface
    {
        $protoRequest = $this->getProductVariantsToProto($request);
        [$protoResult, $status] = $this->protoClient->getProductVariants($protoRequest)->wait();
        if ($status->code !== 0) {
            throw new \RuntimeException($status->details, $status->code);
        }
        return $this->getProductVariantsFromProto($protoResult);
    }

    /**
     * Autogenerated description for getProductVariants method
     *
     * @param ProductVariantRequestInterface $value
     * @return ProductVariantRequest
     */
    private function getProductVariantsToProto(ProductVariantRequestInterface $value): ProductVariantRequest
    {
        // convert data from \Magento\CatalogStorefrontApi\Api\Data\ProductVariantRequest
        // to \Magento\CatalogStorefrontApi\Proto\ProductVariantRequest
        /** @var \Magento\CatalogStorefrontApi\Api\Data\ProductVariantRequest $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Proto\ProductVariantRequest();
            $r->setProductId($value->getProductId());
            $r->setStore($value->getStore());
            return $r;
        };
        $proto = $p();

        return $proto;
    }

    /**
     * Autogenerated description for getProductVariants method
     *
     * @param ProductVariantResponse $value
     * @return ProductVariantResponseInterface
     * phpcs:disable Generic.Metrics.NestingLevel.TooHigh
     */
    private function getProductVariantsFromProto(ProductVariantResponse $value): ProductVariantResponseInterface
    {
        // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse
        // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse
        /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse();
            $res = [];
            foreach ($value->getMatchedVariants() as $item1) {
                // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariant
                // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariant
                /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariant $item1 **/
                $p = function () use ($item1) {
                    $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariant();
                    $r->setId($item1->getId());
                    $values = [];
                    foreach ($item1->getOptionValues() as $newValue) {
                        $values[] = $newValue;
                    }
                    $r->setOptionValues($values);
                    $r->setProductId($item1->getProductId());
                    return $r;
                };
                $out = $p();
                $res[] = $out;
            }
            $r->setMatchedVariants($res);
            return $r;
        };
        $out = $p();

        return $out;
    }

    /**
     * @inheritdoc
     *
     * @param OptionSelectionRequestInterface $request
     * @return ProductVariantResponseInterface
     * @throws \Throwable
     */
    public function getVariantsMatch(OptionSelectionRequestInterface $request): ProductVariantResponseInterface
    {
        $protoRequest = $this->getVariantsMatchToProto($request);
        [$protoResult, $status] = $this->protoClient->getVariantsMatch($protoRequest)->wait();
        if ($status->code !== 0) {
            throw new \RuntimeException($status->details, $status->code);
        }
        return $this->getVariantsMatchFromProto($protoResult);
    }

    /**
     * Autogenerated description for getVariantsMatch method
     *
     * @param OptionSelectionRequestInterface $value
     * @return OptionSelectionRequest
     */
    private function getVariantsMatchToProto(OptionSelectionRequestInterface $value): OptionSelectionRequest
    {
        // convert data from \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequest
        // to \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest
        /** @var \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequest $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest();
            $r->setStore($value->getStore());
            $values = [];
            foreach ($value->getValues() as $newValue) {
                $values[] = $newValue;
            }
            $r->setValues($values);
            return $r;
        };
        $proto = $p();

        return $proto;
    }

    /**
     * Autogenerated description for getVariantsMatch method
     *
     * @param ProductVariantResponse $value
     * @return ProductVariantResponseInterface
     * phpcs:disable Generic.Metrics.NestingLevel.TooHigh
     */
    private function getVariantsMatchFromProto(ProductVariantResponse $value): ProductVariantResponseInterface
    {
        // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse
        // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse
        /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse();
            $res = [];
            foreach ($value->getMatchedVariants() as $item1) {
                // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariant
                // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariant
                /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariant $item1 **/
                $p = function () use ($item1) {
                    $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariant();
                    $r->setId($item1->getId());
                    $values = [];
                    foreach ($item1->getOptionValues() as $newValue) {
                        $values[] = $newValue;
                    }
                    $r->setOptionValues($values);
                    $r->setProductId($item1->getProductId());
                    return $r;
                };
                $out = $p();
                $res[] = $out;
            }
            $r->setMatchedVariants($res);
            return $r;
        };
        $out = $p();

        return $out;
    }

    /**
     * @inheritdoc
     *
     * @param OptionSelectionRequestInterface $request
     * @return ProductVariantResponseInterface
     * @throws \Throwable
     */
    public function getVariantsExactlyMatch(OptionSelectionRequestInterface $request): ProductVariantResponseInterface
    {
        $protoRequest = $this->getVariantsExactlyMatchToProto($request);
        [$protoResult, $status] = $this->protoClient->getVariantsExactlyMatch($protoRequest)->wait();
        if ($status->code !== 0) {
            throw new \RuntimeException($status->details, $status->code);
        }
        return $this->getVariantsExactlyMatchFromProto($protoResult);
    }

    /**
     * Autogenerated description for getVariantsExactlyMatch method
     *
     * @param OptionSelectionRequestInterface $value
     * @return OptionSelectionRequest
     */
    private function getVariantsExactlyMatchToProto(OptionSelectionRequestInterface $value): OptionSelectionRequest
    {
        // convert data from \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequest
        // to \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest
        /** @var \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequest $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest();
            $r->setStore($value->getStore());
            $values = [];
            foreach ($value->getValues() as $newValue) {
                $values[] = $newValue;
            }
            $r->setValues($values);
            return $r;
        };
        $proto = $p();

        return $proto;
    }

    /**
     * Autogenerated description for getVariantsExactlyMatch method
     *
     * @param ProductVariantResponse $value
     * @return ProductVariantResponseInterface
     * phpcs:disable Generic.Metrics.NestingLevel.TooHigh
     */
    private function getVariantsExactlyMatchFromProto(ProductVariantResponse $value): ProductVariantResponseInterface
    {
        // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse
        // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse
        /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse();
            $res = [];
            foreach ($value->getMatchedVariants() as $item1) {
                // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariant
                // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariant
                /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariant $item1 **/
                $p = function () use ($item1) {
                    $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariant();
                    $r->setId($item1->getId());
                    $values = [];
                    foreach ($item1->getOptionValues() as $newValue) {
                        $values[] = $newValue;
                    }
                    $r->setOptionValues($values);
                    $r->setProductId($item1->getProductId());
                    return $r;
                };
                $out = $p();
                $res[] = $out;
            }
            $r->setMatchedVariants($res);
            return $r;
        };
        $out = $p();

        return $out;
    }

    /**
     * @inheritdoc
     *
     * @param OptionSelectionRequestInterface $request
     * @return ProductVariantResponseInterface
     * @throws \Throwable
     */
    public function getVariantsInclude(OptionSelectionRequestInterface $request): ProductVariantResponseInterface
    {
        $protoRequest = $this->getVariantsIncludeToProto($request);
        [$protoResult, $status] = $this->protoClient->getVariantsInclude($protoRequest)->wait();
        if ($status->code !== 0) {
            throw new \RuntimeException($status->details, $status->code);
        }
        return $this->getVariantsIncludeFromProto($protoResult);
    }

    /**
     * Autogenerated description for getVariantsInclude method
     *
     * @param OptionSelectionRequestInterface $value
     * @return OptionSelectionRequest
     */
    private function getVariantsIncludeToProto(OptionSelectionRequestInterface $value): OptionSelectionRequest
    {
        // convert data from \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequest
        // to \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest
        /** @var \Magento\CatalogStorefrontApi\Api\Data\OptionSelectionRequest $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Proto\OptionSelectionRequest();
            $r->setStore($value->getStore());
            $values = [];
            foreach ($value->getValues() as $newValue) {
                $values[] = $newValue;
            }
            $r->setValues($values);
            return $r;
        };
        $proto = $p();

        return $proto;
    }

    /**
     * Autogenerated description for getVariantsInclude method
     *
     * @param ProductVariantResponse $value
     * @return ProductVariantResponseInterface
     * phpcs:disable Generic.Metrics.NestingLevel.TooHigh
     */
    private function getVariantsIncludeFromProto(ProductVariantResponse $value): ProductVariantResponseInterface
    {
        // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse
        // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse
        /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariantResponse $value **/
        $p = function () use ($value) {
            $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariantResponse();
            $res = [];
            foreach ($value->getMatchedVariants() as $item1) {
                // convert data from \Magento\CatalogStorefrontApi\Proto\ProductVariant
                // to \Magento\CatalogStorefrontApi\Api\Data\ProductVariant
                /** @var \Magento\CatalogStorefrontApi\Proto\ProductVariant $item1 **/
                $p = function () use ($item1) {
                    $r = new \Magento\CatalogStorefrontApi\Api\Data\ProductVariant();
                    $r->setId($item1->getId());
                    $values = [];
                    foreach ($item1->getOptionValues() as $newValue) {
                        $values[] = $newValue;
                    }
                    $r->setOptionValues($values);
                    $r->setProductId($item1->getProductId());
                    return $r;
                };
                $out = $p();
                $res[] = $out;
            }
            $r->setMatchedVariants($res);
            return $r;
        };
        $out = $p();

        return $out;
    }
}
